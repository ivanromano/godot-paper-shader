[gd_scene load_steps=6 format=3 uid="uid://bfcs2ntcb6p3x"]

[ext_resource type="Shader" uid="uid://cu6pcbvle8kpv" path="res://shaders/ui/paper.gdshader" id="1_4dvvg"]
[ext_resource type="Texture2D" uid="uid://bptvjtbx2x7rl" path="res://img/Captura de pantalla 2025-08-09 014448.jpg" id="2_rnjyy"]

[sub_resource type="ShaderMaterial" id="ShaderMaterial_6e84v"]
shader = ExtResource("1_4dvvg")
shader_parameter/fill_color = Color(1, 0.94509804, 0.8, 1)
shader_parameter/border_color = Color(0.91764706, 0.7647059, 0.40392157, 1)
shader_parameter/size = Vector2(0.715, 0.515)
shader_parameter/spikes_north = 4
shader_parameter/spikes_east = 2
shader_parameter/spikes_south = 8
shader_parameter/spikes_west = 3
shader_parameter/spike_amplitude = 0.110000005225
shader_parameter/seed = 234.7650111513375
shader_parameter/border_thickness = 0.0
shader_parameter/pixel_density = 63.6090028314275

[sub_resource type="Shader" id="Shader_4dvvg"]
code = "shader_type canvas_item;

// colores
uniform vec4 fill_color : source_color = vec4(1.0, 0.95, 0.8, 1.0);
uniform vec4 border_color : source_color = vec4(0.9, 0.7, 0.3, 1.0);

// forma base (half extents en uv -1..1)
uniform vec2 size = vec2(0.6, 0.4);

// ruido / forma
uniform float edge_sharpness : hint_range(0.0, 20.0) = 10.0;
uniform float noise_strength : hint_range(0.0, 0.5) = 0.08;
uniform float seed : hint_range(0.0, 10.0) = 0.0;

// borde y pixel-art
uniform float border_thickness : hint_range(0.0, 0.6) = 0.06;
uniform float pixel_density : hint_range(4.0, 1024.0) = 48.0;

// control de puntas (por dirección)
uniform int spikes_north = 6;
uniform int spikes_east = 8;
uniform int spikes_south = 6;
uniform int spikes_west = 8;

// control de la forma de las puntas
uniform float spike_amplitude : hint_range(0.0, 1.0) = 0.18;
uniform float spike_sharpness : hint_range(1.0, 64.0) = 8.0;






// constantes
// calcula contribución de puntas distribuidas a lo largo de un eje
float side_spike_contrib(int count, float coord, float sharpness) {
    if (count <= 0) return 0.0;
    float c = float(count);
    // coord en -1..1 -> llevamos a 0..1
    float u = (coord * 0.5) + 0.5;
    // coseno con frecuencia count
    float w = cos(u * c * 2.0 * PI);
    float m = max(0.0, (w + 1.0) * 0.5);
    return pow(m, sharpness);
}

// --- ruido simple ---
float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453 + seed);
}

float noise(vec2 p){
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = f*f*(3.0-2.0*f);
    return mix(
        mix(hash(i + vec2(0.0,0.0)), hash(i + vec2(1.0,0.0)), u.x),
        mix(hash(i + vec2(0.0,1.0)), hash(i + vec2(1.0,1.0)), u.x),
        u.y
    );
}

// contribución de puntas para una dirección con centro angular center_ang (radians)
float dir_spike_contrib(int count, float center_ang, float angle) {
    if (count <= 0) { return 0.0; }
    float c = float(count);
    // la función tiene picos alrededor de center_ang con frecuencia c
    float w = cos(c * (angle - center_ang));
    float m = max(0.0, (w + 1.0) * 0.5);
    return pow(m, spike_sharpness);
}


//Error en la línea 94: Argumentos inválidos para la función integrada: \"vec2(vec2,float)\".
void fragment() {
    vec2 uv = (UV - 0.5) * 2.0;

    float half_w = size.x;
    float half_h = size.y;

    float dx = abs(uv.x) - half_w;
    float dy = abs(uv.y) - half_h;
    float dist_to_edge = max(dx, dy);

    // --- puntas por lado ---
    float contrib_n = side_spike_contrib(spikes_north, uv.x / half_w, spike_sharpness) * step(dy, dx);
    float contrib_s = side_spike_contrib(spikes_south, uv.x / half_w, spike_sharpness) * step(dy, dx);
    float contrib_e = side_spike_contrib(spikes_east, uv.y / half_h, spike_sharpness) * step(dx, dy);
    float contrib_w = side_spike_contrib(spikes_west, uv.y / half_h, spike_sharpness) * step(dx, dy);

    float dir_contrib = max(max(contrib_n, contrib_s), max(contrib_e, contrib_w));

    // deformación por ruido
    //float n = noise(vec2(uv * edge_sharpness + seed, 0.0));
	//float n = noise(vec2(uv * edge_sharpness + seed, 0.0));
	//float n = noise(vec3(uv * edge_sharpness + seed, 0.0));
	float n = noise(uv * edge_sharpness + seed);

    float deform = (n - 0.5) * noise_strength;

    float deform_with_spikes = deform + dir_contrib * spike_amplitude;

    float px = 2.0 / max(pixel_density, 1.0);
    float signed_dist = dist_to_edge - deform_with_spikes;
    float signed_dist_q = floor(signed_dist / px + 0.5) * px;
    float border_q = max(px, floor(border_thickness / px + 0.5) * px);

    if (signed_dist_q < -border_q) {
        COLOR = fill_color;
    } else if (signed_dist_q < 0.0) {
        COLOR = border_color;
    } else {
        COLOR = vec4(0.0);
    }
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_rnjyy"]
shader = SubResource("Shader_4dvvg")
shader_parameter/fill_color = Color(1, 0.94509804, 0.8, 1)
shader_parameter/border_color = Color(0.91764706, 0.7647059, 0.40392157, 1)
shader_parameter/size = Vector2(0.905, 0.81)
shader_parameter/edge_sharpness = 11.10400052744
shader_parameter/noise_strength = 0.142000006745
shader_parameter/seed = 9.2250004381875
shader_parameter/border_thickness = 0.0550000026125
shader_parameter/pixel_density = 340.850016000375
shader_parameter/spikes_north = 61
shader_parameter/spikes_east = -92
shader_parameter/spikes_south = 6
shader_parameter/spikes_west = 8
shader_parameter/spike_amplitude = 0.0190000009025
shader_parameter/spike_sharpness = 8.750000368125

[node name="Node2D" type="Node2D"]

[node name="ColorRect" type="ColorRect" parent="."]
material = SubResource("ShaderMaterial_6e84v")
offset_left = 940.0
offset_top = 182.0
offset_right = 1017.0
offset_bottom = 242.0

[node name="ColorRect2" type="ColorRect" parent="."]
visible = false
material = SubResource("ShaderMaterial_rnjyy")
offset_left = 80.0
offset_top = 12.0
offset_right = 157.0
offset_bottom = 72.0

[node name="CapturaDePantalla20250809014448" type="Sprite2D" parent="."]
visible = false
texture_filter = 1
position = Vector2(521, 76)
texture = ExtResource("2_rnjyy")
